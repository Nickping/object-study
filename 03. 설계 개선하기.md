### 03. 설계 개선하기
문제점 : `Theater`클래스가 `Audience`, `TicketSeller`에 결합됨. 
-> `Theater`클래스가 `Audience`, `TicketSeller`에 접근하지 못하도록 정보를 차단. 
`Theater`클래스가 원하는 것은 `Audience`가 입장했다는 정보 뿐. 

관람객이 알아서 가방안의 현금과 초대장을 관리하고 판매원이 스스로 매표소의 티켓과 판매요금을 다루게 한다. 
-> 즉 관람객과 판매원을 자율적인 존재로 만든다.


#### 자율성을 높이자
`Audience`  와 `TicketSeller` 가 직접 `Bag`과 `TicketOffice`를 관리한다. 

`Theater` 의 `enter`메소드에서 `TicketOffice`에 접근하는 모든 코드를 `TicketSeller`내부로 숨긴다. `TicketSeller`에 `sellTo(Audience)`를 추가한다. 

1. Theater와 TicketOffice의 결합 제거

ticketSeller가 직접 ticketOffice를 관리. ticketOffice와 Theater간의 결합성을 없앤다. 
``` swift
class TicketSeller {
    private var ticketOffice: TicketOffice
    
    init(ticketOffice: TicketOffice) {
        self.ticketOffice = ticketOffice
    }
    
    func sellTo(audience: Audience) {
        if audience.bag.hasInvitation() {
            guard let ticket = ticketOffice.getTicket() else { return }
            audience.bag.minusAmount(amount: ticket.fee)
            ticketOffice.plusAmount(amount: ticket.fee)
            audience.bag.setTicket(ticket: ticket)
        } else {
            guard let ticket = ticketOffice.getTicket() else { return }
            audience.bag.minusAmount(amount: ticket.fee)
            ticketOffice.plusAmount(amount: ticket.fee)
            audience.bag.setTicket(ticket: ticket)
        }
    }
}
```


Theater의 enter 메소드에서 직접 ticketSeller를 통해 ticketOffice에 접근하지 않는다. TicketSeller의 interface로만 접근. 
``` swift
class Theater {
    private var ticketSeller: TicketSeller
    
    init(ticketSeller: TicketSeller) {
        self.ticketSeller = ticketSeller
    }
    
    func enter(audience: Audience) {
        ticketSeller.sellTo(audience: audience)
    }
}
```

> 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 기본적인 원칙.   

2. TicketSeller와 Audience의 결합성 제거. 
여전히 ticketSeller는 audience의 bag에 접근한다. Audience를 자율적인 존재로 변경한다. Audience에 buy 메소드 추가. 

audience의 bag 프로퍼티는 private으로 변경. 
``` swift
class Audience {
    private var bag: Bag
    
    init(bag: Bag) {
        self.bag = bag
    }
    
    func buy(ticket: Ticket) -> Int {
        if bag.hasInvitation() {
            bag.minusAmount(amount: ticket.fee)
            bag.setTicket(ticket: ticket)
            return 0
        } else {
            bag.minusAmount(amount: ticket.fee)
            bag.setTicket(ticket: ticket)
            return ticket.fee
        }
    }
}
```

TicketSeller는 audience의 buy 메소드만 호출한다. 
``` swift
class TicketSeller {
    private var ticketOffice: TicketOffice
    
    init(ticketOffice: TicketOffice) {
        self.ticketOffice = ticketOffice
    }
    
    func sellTo(audience: Audience) {
        guard let ticket = ticketOffice.getTicket() else { return }
        ticketOffice.plusAmount(amount: audience.buy(ticket: ticket))
    }
}

```

-> Audience와 TicketSeller는 더이상 내부구현을 외부에 유출하지 않고 스스로 책임지고 해결한다. -> 자율적인 존재.

* Audience와 TicketSeller 내부 구현이 변경되어도 더이상 Theater는 변경되지 않는다. 
* Audience의 Bag, TicketSeller의 ticketOffice가 변경되어도 내부에서 해결된다. 